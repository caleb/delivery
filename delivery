#!/usr/bin/env boot

(set-env! :dependencies '[[me.raynes/conch "0.8.0"]
                          [org.clojure/core.incubator "0.1.4"]
                          [org.clojure/clojure "1.9.0-alpha16"]])
(require '[me.raynes.conch :refer [with-programs]]
         '[me.raynes.conch.low-level :as sh]
         '[clojure.edn :as edn]
         '[clojure.string :as string]
         '[clojure.spec.alpha :as s]
         '[clojure.core.strint :refer [<<]]
         '[clojure.java.io :refer [file spit]]
         '[boot.cli :refer [defclifn]])

;;
;; Configuration Spec
;;
(s/def ::string string?)
(s/def ::integer integer?)
(s/def ::host ::string)
(s/def ::user ::string)
(s/def ::port ::integer)
(s/def ::recipe ::string)
(s/def ::run-list (s/coll-of ::recipe))

(def config-spec (s/keys :opt-un [::host
                                  ::user
                                  ::run-list
                                  ::port]))

(defn runtime-error
  ([message]
   (runtime-error message {}))
  ([message data]
   (throw (ex-info message (merge {::message message}
                                  data))))
  ([message data cause]
   (throw (ex-info message (merge {::message message} data) cause))))

(defn write-if-missing [f contents]
  (when-not (.exists (file f))
    (spit f contents)))

(defn command-exists? [cmd]
  (try
    (with-programs [which]
      (which cmd)
      true)
    (catch clojure.lang.ExceptionInfo e
      false)))

(defn config-error [explain-data]
  (str "Expected "
       (-> explain-data :path first)
       " to conform to "
       (-> explain-data :pred)
       " but got "
       (-> explain-data :val)))

(defn validate-config [f config-edn]
  (if (s/valid? config-spec config-edn)
    (s/conform config-spec config-edn)
    (let [explain-data (s/explain-data config-spec config-edn)
          header       (str "Delivery configuration file \"" f "\" is invalid")]
      (runtime-error (str header
                          "\n"
                          (string/join (repeat (count header) "-"))
                          "\n"
                          (string/join "\n" (map config-error (:clojure.spec.alpha/problems explain-data))))))))

(defn read-config [f]
  (if (.exists f)
    (let [config-edn (edn/read-string (slurp f))]
      (validate-config f config-edn))
    (runtime-error (str "Configuration file \"" f "\" doesn't exist"))))

(defn create-context [options args]
  (let [config-file (file (or (:config options)))
        project-dir (.. config-file getAbsoluteFile getParent)
        config      (read-config config-file)]
    {:command     (first args)
     :args        (rest args)
     :host        (or (:host options) (:host config))
     :port        (or (:port options) (:port config))
     :run-list    (or (:run-list options) (:run-list config))
     :user        (or (:user options) (:user config))
     :config-file config-file
     :project-dir project-dir}))

(defmulti task (fn [command & args] command))
(defmethod task :init
  [options args]
  (println "INIT")
  (let [command      (first args)
        target-dir   (second args)
        project-dir  (file target-dir)
        project-name (.getName project-dir)]
    (write-if-missing (file (:project-dir context) "Policyfile.rb")
                      (<< "name '~{project-name}'\n"
                          "run_list '~{project-name::default}'\n"
                          "default_source :supermarket\n"
                          "cookbook '~{project-name}', '~> 0.1.0', path: 'cookbooks/~{project-name}'"))))

(defmethod task :deploy
  [options args]
  (let [context (create-context options args)]
    (println "DEPLOY")))

(defclifn -main
  "A simple server provisioning tool using Chef Zero"
  [_ host HOST str "specify the host to deploy to"
   p port PORT str "specify the port to use for SSH (default 22)"
   c config CONFIG str "the config file to read (default delivery.edn)"
   r run-list RUN_LIST str "the run-list to execute on HOST"
   u user USER str "the user to deploy as (default root)"]
  (try
    (let [command (-> (first *args*) keyword)
          options {:host host
                   :port port
                   :config config
                   :run-list run-list
                   :user user}]
      (if (get-method task command)
        (task options *args*)
        (*usage*)))
    (catch clojure.lang.ExceptionInfo e
      (let [d (-> e ex-data)]
        (if (::message d)
          (println (::message d))
          (throw e))))))
